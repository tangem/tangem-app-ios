// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos_1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
@preconcurrency import SwiftProtobuf    // [REDACTED_TODO_COMMENT]

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CosmosProtoMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegateContainer: CosmosProtoMessage.CosmosMessageDelegateContainer {
    get {return _delegateContainer ?? CosmosProtoMessage.CosmosMessageDelegateContainer()}
    set {_delegateContainer = newValue}
  }
  /// Returns true if `delegateContainer` has been explicitly set.
  var hasDelegateContainer: Bool {return self._delegateContainer != nil}
  /// Clears the value of `delegateContainer`. Subsequent reads from it will return its default value.
  mutating func clearDelegateContainer() {self._delegateContainer = nil}

  var feeAndKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer {
    get {return _feeAndKeyContainer ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer()}
    set {_feeAndKeyContainer = newValue}
  }
  /// Returns true if `feeAndKeyContainer` has been explicitly set.
  var hasFeeAndKeyContainer: Bool {return self._feeAndKeyContainer != nil}
  /// Clears the value of `feeAndKeyContainer`. Subsequent reads from it will return its default value.
  mutating func clearFeeAndKeyContainer() {self._feeAndKeyContainer = nil}

  var chainID: String = String()

  var accountNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CosmosMessageDelegateContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var delegate: CosmosProtoMessage.CosmosMessageDelegate {
      get {return _delegate ?? CosmosProtoMessage.CosmosMessageDelegate()}
      set {_delegate = newValue}
    }
    /// Returns true if `delegate` has been explicitly set.
    var hasDelegate: Bool {return self._delegate != nil}
    /// Clears the value of `delegate`. Subsequent reads from it will return its default value.
    mutating func clearDelegate() {self._delegate = nil}

    var stakingProvider: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DelegateData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var delegatorAddress: String = String()

      var validatorAddress: String = String()

      var delegateAmount: CosmosProtoMessage.DelegateAmount {
        get {return _delegateAmount ?? CosmosProtoMessage.DelegateAmount()}
        set {_delegateAmount = newValue}
      }
      /// Returns true if `delegateAmount` has been explicitly set.
      var hasDelegateAmount: Bool {return self._delegateAmount != nil}
      /// Clears the value of `delegateAmount`. Subsequent reads from it will return its default value.
      mutating func clearDelegateAmount() {self._delegateAmount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _delegateAmount: CosmosProtoMessage.DelegateAmount? = nil
    }

    struct RedelegateData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var delegatorAddress: String = String()

      var validatorSrcAddress: String = String()

      var validatorDstAddress: String = String()

      var delegateAmount: CosmosProtoMessage.DelegateAmount {
        get {return _delegateAmount ?? CosmosProtoMessage.DelegateAmount()}
        set {_delegateAmount = newValue}
      }
      /// Returns true if `delegateAmount` has been explicitly set.
      var hasDelegateAmount: Bool {return self._delegateAmount != nil}
      /// Clears the value of `delegateAmount`. Subsequent reads from it will return its default value.
      mutating func clearDelegateAmount() {self._delegateAmount = nil}

      var typePrefix: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _delegateAmount: CosmosProtoMessage.DelegateAmount? = nil
    }

    init() {}

    fileprivate var _delegate: CosmosProtoMessage.CosmosMessageDelegate? = nil
  }

  struct DelegateAmount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var denomination: String = String()

    var amount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CosmosMessageDelegate: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageType: String = String()

    var delegateData: Data {
      get {return _delegateData ?? Data()}
      set {_delegateData = newValue}
    }
    /// Returns true if `delegateData` has been explicitly set.
    var hasDelegateData: Bool {return self._delegateData != nil}
    /// Clears the value of `delegateData`. Subsequent reads from it will return its default value.
    mutating func clearDelegateData() {self._delegateData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegateData: Data? = nil
  }

  struct CosmosMessageFeeAndKeyContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer {
      get {return _publicKeyContainer ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer()}
      set {_publicKeyContainer = newValue}
    }
    /// Returns true if `publicKeyContainer` has been explicitly set.
    var hasPublicKeyContainer: Bool {return self._publicKeyContainer != nil}
    /// Clears the value of `publicKeyContainer`. Subsequent reads from it will return its default value.
    mutating func clearPublicKeyContainer() {self._publicKeyContainer = nil}

    var feeContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer {
      get {return _feeContainer ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer()}
      set {_feeContainer = newValue}
    }
    /// Returns true if `feeContainer` has been explicitly set.
    var hasFeeContainer: Bool {return self._feeContainer != nil}
    /// Clears the value of `feeContainer`. Subsequent reads from it will return its default value.
    mutating func clearFeeContainer() {self._feeContainer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct CosmosMessagePublicKeyContainer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var publicKeyWrapper: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper {
        get {return _publicKeyWrapper ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper()}
        set {_publicKeyWrapper = newValue}
      }
      /// Returns true if `publicKeyWrapper` has been explicitly set.
      var hasPublicKeyWrapper: Bool {return self._publicKeyWrapper != nil}
      /// Clears the value of `publicKeyWrapper`. Subsequent reads from it will return its default value.
      mutating func clearPublicKeyWrapper() {self._publicKeyWrapper = nil}

      var publicKeyParamWrapper: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper {
        get {return _publicKeyParamWrapper ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper()}
        set {_publicKeyParamWrapper = newValue}
      }
      /// Returns true if `publicKeyParamWrapper` has been explicitly set.
      var hasPublicKeyParamWrapper: Bool {return self._publicKeyParamWrapper != nil}
      /// Clears the value of `publicKeyParamWrapper`. Subsequent reads from it will return its default value.
      mutating func clearPublicKeyParamWrapper() {self._publicKeyParamWrapper = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct CosmosMessagePublicKeyWrapper: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var publicKeyType: String = String()

        var publicKey: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey {
          get {return _publicKey ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey()}
          set {_publicKey = newValue}
        }
        /// Returns true if `publicKey` has been explicitly set.
        var hasPublicKey: Bool {return self._publicKey != nil}
        /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
        mutating func clearPublicKey() {self._publicKey = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct CosmosMessagePublicKey: @unchecked Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var publicKey: Data = Data()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}

        fileprivate var _publicKey: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey? = nil
      }

      struct CosmosMessagePublicKeyParamWrapper: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var publicKeyParam: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam {
          get {return _publicKeyParam ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam()}
          set {_publicKeyParam = newValue}
        }
        /// Returns true if `publicKeyParam` has been explicitly set.
        var hasPublicKeyParam: Bool {return self._publicKeyParam != nil}
        /// Clears the value of `publicKeyParam`. Subsequent reads from it will return its default value.
        mutating func clearPublicKeyParam() {self._publicKeyParam = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct CosmosMessagePublicKeyParam: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var param: Int32 = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}

        fileprivate var _publicKeyParam: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam? = nil
      }

      init() {}

      fileprivate var _publicKeyWrapper: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper? = nil
      fileprivate var _publicKeyParamWrapper: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper? = nil
    }

    struct CosmosMessageFeeContainer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var feeAmount: CosmosProtoMessage.DelegateAmount {
        get {return _feeAmount ?? CosmosProtoMessage.DelegateAmount()}
        set {_feeAmount = newValue}
      }
      /// Returns true if `feeAmount` has been explicitly set.
      var hasFeeAmount: Bool {return self._feeAmount != nil}
      /// Clears the value of `feeAmount`. Subsequent reads from it will return its default value.
      mutating func clearFeeAmount() {self._feeAmount = nil}

      var gas: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _feeAmount: CosmosProtoMessage.DelegateAmount? = nil
    }

    init() {}

    fileprivate var _publicKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer? = nil
    fileprivate var _feeContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer? = nil
  }

  init() {}

  fileprivate var _delegateContainer: CosmosProtoMessage.CosmosMessageDelegateContainer? = nil
  fileprivate var _feeAndKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension CosmosProtoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CosmosProtoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegate_container"),
    2: .standard(proto: "fee_and_key_container"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegateContainer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeAndKeyContainer) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegateContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feeAndKeyContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.accountNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage, rhs: CosmosProtoMessage) -> Bool {
    if lhs._delegateContainer != rhs._delegateContainer {return false}
    if lhs._feeAndKeyContainer != rhs._feeAndKeyContainer {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegateContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageDelegateContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegate"),
    2: .standard(proto: "staking_provider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakingProvider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stakingProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingProvider, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegateContainer, rhs: CosmosProtoMessage.CosmosMessageDelegateContainer) -> Bool {
    if lhs._delegate != rhs._delegate {return false}
    if lhs.stakingProvider != rhs.stakingProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegateContainer.DelegateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageDelegateContainer.protoMessageName + ".DelegateData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "validator_address"),
    3: .standard(proto: "delegate_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._delegateAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    try { if let v = self._delegateAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegateContainer.DelegateData, rhs: CosmosProtoMessage.CosmosMessageDelegateContainer.DelegateData) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs._delegateAmount != rhs._delegateAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegateContainer.RedelegateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageDelegateContainer.protoMessageName + ".RedelegateData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "validator_src_address"),
    3: .standard(proto: "validator_dst_address"),
    4: .standard(proto: "delegate_amount"),
    5: .standard(proto: "type_prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorSrcAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.validatorDstAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._delegateAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.typePrefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorSrcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorSrcAddress, fieldNumber: 2)
    }
    if !self.validatorDstAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorDstAddress, fieldNumber: 3)
    }
    try { if let v = self._delegateAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.typePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.typePrefix, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegateContainer.RedelegateData, rhs: CosmosProtoMessage.CosmosMessageDelegateContainer.RedelegateData) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorSrcAddress != rhs.validatorSrcAddress {return false}
    if lhs.validatorDstAddress != rhs.validatorDstAddress {return false}
    if lhs._delegateAmount != rhs._delegateAmount {return false}
    if lhs.typePrefix != rhs.typePrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.DelegateAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".DelegateAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denomination"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denomination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denomination.isEmpty {
      try visitor.visitSingularStringField(value: self.denomination, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.DelegateAmount, rhs: CosmosProtoMessage.DelegateAmount) -> Bool {
    if lhs.denomination != rhs.denomination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageDelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_type"),
    2: .standard(proto: "delegate_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._delegateData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageType.isEmpty {
      try visitor.visitSingularStringField(value: self.messageType, fieldNumber: 1)
    }
    try { if let v = self._delegateData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegate, rhs: CosmosProtoMessage.CosmosMessageDelegate) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs._delegateData != rhs._delegateData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageFeeAndKeyContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_container"),
    2: .standard(proto: "fee_container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyContainer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeContainer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feeContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer) -> Bool {
    if lhs._publicKeyContainer != rhs._publicKeyContainer {return false}
    if lhs._feeContainer != rhs._feeContainer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.protoMessageName + ".CosmosMessagePublicKeyContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_wrapper"),
    2: .standard(proto: "public_key_param_wrapper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyWrapper) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKeyParamWrapper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKeyParamWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer) -> Bool {
    if lhs._publicKeyWrapper != rhs._publicKeyWrapper {return false}
    if lhs._publicKeyParamWrapper != rhs._publicKeyParamWrapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.protoMessageName + ".CosmosMessagePublicKeyWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_type"),
    2: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKeyType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKeyType.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyType, fieldNumber: 1)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper) -> Bool {
    if lhs.publicKeyType != rhs.publicKeyType {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.protoMessageName + ".CosmosMessagePublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyWrapper.CosmosMessagePublicKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.protoMessageName + ".CosmosMessagePublicKeyParamWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyParam) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyParam {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper) -> Bool {
    if lhs._publicKeyParam != rhs._publicKeyParam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.protoMessageName + ".CosmosMessagePublicKeyParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.param) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.param != 0 {
      try visitor.visitSingularInt32Field(value: self.param, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessagePublicKeyContainer.CosmosMessagePublicKeyParamWrapper.CosmosMessagePublicKeyParam) -> Bool {
    if lhs.param != rhs.param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.protoMessageName + ".CosmosMessageFeeContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fee_amount"),
    2: .same(proto: "gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feeAmount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._feeAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer.CosmosMessageFeeContainer) -> Bool {
    if lhs._feeAmount != rhs._feeAmount {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
