// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos_1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
@preconcurrency import SwiftProtobuf    // [REDACTED_TODO_COMMENT]

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CosmosProtoMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegateContainer: CosmosProtoMessage.CosmosMessageDelegateContainer {
    get {return _delegateContainer ?? CosmosProtoMessage.CosmosMessageDelegateContainer()}
    set {_delegateContainer = newValue}
  }
  /// Returns true if `delegateContainer` has been explicitly set.
  var hasDelegateContainer: Bool {return self._delegateContainer != nil}
  /// Clears the value of `delegateContainer`. Subsequent reads from it will return its default value.
  mutating func clearDelegateContainer() {self._delegateContainer = nil}

  var feeAndKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer {
    get {return _feeAndKeyContainer ?? CosmosProtoMessage.CosmosMessageFeeAndKeyContainer()}
    set {_feeAndKeyContainer = newValue}
  }
  /// Returns true if `feeAndKeyContainer` has been explicitly set.
  var hasFeeAndKeyContainer: Bool {return self._feeAndKeyContainer != nil}
  /// Clears the value of `feeAndKeyContainer`. Subsequent reads from it will return its default value.
  mutating func clearFeeAndKeyContainer() {self._feeAndKeyContainer = nil}

  var chainID: String = String()

  var accountNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CosmosMessageDelegateContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var delegate: CosmosProtoMessage.CosmosMessageDelegate {
      get {return _delegate ?? CosmosProtoMessage.CosmosMessageDelegate()}
      set {_delegate = newValue}
    }
    /// Returns true if `delegate` has been explicitly set.
    var hasDelegate: Bool {return self._delegate != nil}
    /// Clears the value of `delegate`. Subsequent reads from it will return its default value.
    mutating func clearDelegate() {self._delegate = nil}

    var stakingProvider: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegate: CosmosProtoMessage.CosmosMessageDelegate? = nil
  }

  struct CosmosMessageDelegate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageType: String = String()

    var delegateData: CosmosProtoMessage.DelegateData {
      get {return _delegateData ?? CosmosProtoMessage.DelegateData()}
      set {_delegateData = newValue}
    }
    /// Returns true if `delegateData` has been explicitly set.
    var hasDelegateData: Bool {return self._delegateData != nil}
    /// Clears the value of `delegateData`. Subsequent reads from it will return its default value.
    mutating func clearDelegateData() {self._delegateData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegateData: CosmosProtoMessage.DelegateData? = nil
  }

  struct CosmosMessagePublicKeyContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKeyWrapper: CosmosProtoMessage.CosmosMessagePublicKeyWrapper {
      get {return _publicKeyWrapper ?? CosmosProtoMessage.CosmosMessagePublicKeyWrapper()}
      set {_publicKeyWrapper = newValue}
    }
    /// Returns true if `publicKeyWrapper` has been explicitly set.
    var hasPublicKeyWrapper: Bool {return self._publicKeyWrapper != nil}
    /// Clears the value of `publicKeyWrapper`. Subsequent reads from it will return its default value.
    mutating func clearPublicKeyWrapper() {self._publicKeyWrapper = nil}

    var publicKeyParamWrapper: CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper {
      get {return _publicKeyParamWrapper ?? CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper()}
      set {_publicKeyParamWrapper = newValue}
    }
    /// Returns true if `publicKeyParamWrapper` has been explicitly set.
    var hasPublicKeyParamWrapper: Bool {return self._publicKeyParamWrapper != nil}
    /// Clears the value of `publicKeyParamWrapper`. Subsequent reads from it will return its default value.
    mutating func clearPublicKeyParamWrapper() {self._publicKeyParamWrapper = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKeyWrapper: CosmosProtoMessage.CosmosMessagePublicKeyWrapper? = nil
    fileprivate var _publicKeyParamWrapper: CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper? = nil
  }

  struct CosmosMessagePublicKeyWrapper: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKeyType: String = String()

    var publicKey: CosmosProtoMessage.CosmosMessagePublicKey {
      get {return _publicKey ?? CosmosProtoMessage.CosmosMessagePublicKey()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    mutating func clearPublicKey() {self._publicKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKey: CosmosProtoMessage.CosmosMessagePublicKey? = nil
  }

  struct CosmosMessagePublicKeyParam: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var param: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DelegateData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var delegatorAddress: String = String()

    var validatorAddress: String = String()

    var delegateAmount: CosmosProtoMessage.DelegateAmount {
      get {return _delegateAmount ?? CosmosProtoMessage.DelegateAmount()}
      set {_delegateAmount = newValue}
    }
    /// Returns true if `delegateAmount` has been explicitly set.
    var hasDelegateAmount: Bool {return self._delegateAmount != nil}
    /// Clears the value of `delegateAmount`. Subsequent reads from it will return its default value.
    mutating func clearDelegateAmount() {self._delegateAmount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegateAmount: CosmosProtoMessage.DelegateAmount? = nil
  }

  struct CosmosMessageFeeAndKeyContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKeyContainer: CosmosProtoMessage.CosmosMessagePublicKeyContainer {
      get {return _publicKeyContainer ?? CosmosProtoMessage.CosmosMessagePublicKeyContainer()}
      set {_publicKeyContainer = newValue}
    }
    /// Returns true if `publicKeyContainer` has been explicitly set.
    var hasPublicKeyContainer: Bool {return self._publicKeyContainer != nil}
    /// Clears the value of `publicKeyContainer`. Subsequent reads from it will return its default value.
    mutating func clearPublicKeyContainer() {self._publicKeyContainer = nil}

    var feeContainer: CosmosProtoMessage.CosmosMessageFeeContainer {
      get {return _feeContainer ?? CosmosProtoMessage.CosmosMessageFeeContainer()}
      set {_feeContainer = newValue}
    }
    /// Returns true if `feeContainer` has been explicitly set.
    var hasFeeContainer: Bool {return self._feeContainer != nil}
    /// Clears the value of `feeContainer`. Subsequent reads from it will return its default value.
    mutating func clearFeeContainer() {self._feeContainer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKeyContainer: CosmosProtoMessage.CosmosMessagePublicKeyContainer? = nil
    fileprivate var _feeContainer: CosmosProtoMessage.CosmosMessageFeeContainer? = nil
  }

  struct CosmosMessagePublicKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKey: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CosmosMessagePublicKeyParamWrapper: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKeyParam: CosmosProtoMessage.CosmosMessagePublicKeyParam {
      get {return _publicKeyParam ?? CosmosProtoMessage.CosmosMessagePublicKeyParam()}
      set {_publicKeyParam = newValue}
    }
    /// Returns true if `publicKeyParam` has been explicitly set.
    var hasPublicKeyParam: Bool {return self._publicKeyParam != nil}
    /// Clears the value of `publicKeyParam`. Subsequent reads from it will return its default value.
    mutating func clearPublicKeyParam() {self._publicKeyParam = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKeyParam: CosmosProtoMessage.CosmosMessagePublicKeyParam? = nil
  }

  struct CosmosMessageFeeContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var feeAmount: CosmosProtoMessage.DelegateAmount {
      get {return _feeAmount ?? CosmosProtoMessage.DelegateAmount()}
      set {_feeAmount = newValue}
    }
    /// Returns true if `feeAmount` has been explicitly set.
    var hasFeeAmount: Bool {return self._feeAmount != nil}
    /// Clears the value of `feeAmount`. Subsequent reads from it will return its default value.
    mutating func clearFeeAmount() {self._feeAmount = nil}

    var gas: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _feeAmount: CosmosProtoMessage.DelegateAmount? = nil
  }

  struct DelegateAmount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var denomination: String = String()

    var amount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _delegateContainer: CosmosProtoMessage.CosmosMessageDelegateContainer? = nil
  fileprivate var _feeAndKeyContainer: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension CosmosProtoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CosmosProtoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegateContainer"),
    2: .same(proto: "feeAndKeyContainer"),
    3: .same(proto: "chainId"),
    4: .same(proto: "accountNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegateContainer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeAndKeyContainer) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegateContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feeAndKeyContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.accountNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage, rhs: CosmosProtoMessage) -> Bool {
    if lhs._delegateContainer != rhs._delegateContainer {return false}
    if lhs._feeAndKeyContainer != rhs._feeAndKeyContainer {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegateContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageDelegateContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegate"),
    2: .same(proto: "stakingProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakingProvider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stakingProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingProvider, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegateContainer, rhs: CosmosProtoMessage.CosmosMessageDelegateContainer) -> Bool {
    if lhs._delegate != rhs._delegate {return false}
    if lhs.stakingProvider != rhs.stakingProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageDelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageDelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageType"),
    2: .same(proto: "delegateData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._delegateData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageType.isEmpty {
      try visitor.visitSingularStringField(value: self.messageType, fieldNumber: 1)
    }
    try { if let v = self._delegateData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageDelegate, rhs: CosmosProtoMessage.CosmosMessageDelegate) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs._delegateData != rhs._delegateData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessagePublicKeyContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessagePublicKeyContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeyWrapper"),
    2: .same(proto: "publicKeyParamWrapper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyWrapper) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKeyParamWrapper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKeyParamWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessagePublicKeyContainer, rhs: CosmosProtoMessage.CosmosMessagePublicKeyContainer) -> Bool {
    if lhs._publicKeyWrapper != rhs._publicKeyWrapper {return false}
    if lhs._publicKeyParamWrapper != rhs._publicKeyParamWrapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessagePublicKeyWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessagePublicKeyWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeyType"),
    2: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKeyType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKeyType.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyType, fieldNumber: 1)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessagePublicKeyWrapper, rhs: CosmosProtoMessage.CosmosMessagePublicKeyWrapper) -> Bool {
    if lhs.publicKeyType != rhs.publicKeyType {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessagePublicKeyParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessagePublicKeyParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.param) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.param != 0 {
      try visitor.visitSingularInt32Field(value: self.param, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessagePublicKeyParam, rhs: CosmosProtoMessage.CosmosMessagePublicKeyParam) -> Bool {
    if lhs.param != rhs.param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.DelegateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".DelegateData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegatorAddress"),
    2: .same(proto: "validatorAddress"),
    3: .same(proto: "delegateAmount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._delegateAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    try { if let v = self._delegateAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.DelegateData, rhs: CosmosProtoMessage.DelegateData) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs._delegateAmount != rhs._delegateAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeAndKeyContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageFeeAndKeyContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeyContainer"),
    2: .same(proto: "feeContainer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyContainer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeContainer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feeContainer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer, rhs: CosmosProtoMessage.CosmosMessageFeeAndKeyContainer) -> Bool {
    if lhs._publicKeyContainer != rhs._publicKeyContainer {return false}
    if lhs._feeContainer != rhs._feeContainer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessagePublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessagePublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessagePublicKey, rhs: CosmosProtoMessage.CosmosMessagePublicKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessagePublicKeyParamWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeyParam"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKeyParam) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKeyParam {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper, rhs: CosmosProtoMessage.CosmosMessagePublicKeyParamWrapper) -> Bool {
    if lhs._publicKeyParam != rhs._publicKeyParam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.CosmosMessageFeeContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".CosmosMessageFeeContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feeAmount"),
    2: .same(proto: "gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feeAmount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._feeAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.CosmosMessageFeeContainer, rhs: CosmosProtoMessage.CosmosMessageFeeContainer) -> Bool {
    if lhs._feeAmount != rhs._feeAmount {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosmosProtoMessage.DelegateAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CosmosProtoMessage.protoMessageName + ".DelegateAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denomination"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denomination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denomination.isEmpty {
      try visitor.visitSingularStringField(value: self.denomination, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CosmosProtoMessage.DelegateAmount, rhs: CosmosProtoMessage.DelegateAmount) -> Bool {
    if lhs.denomination != rhs.denomination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
