// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Koinos_Protocol_object_space {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var system: Bool = false

  var zone: Data = Data()

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_event_data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence: UInt32 = 0

  var source: Data = Data()

  var name: String = String()

  var data: Data = Data()

  var impacted: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_contract_call_bundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contractID: Data = Data()

  var entryPoint: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_system_call_target {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Koinos_Protocol_system_call_target.OneOf_Target? = nil

  var thunkID: UInt32 {
    get {
      if case .thunkID(let v)? = target {return v}
      return 0
    }
    set {target = .thunkID(newValue)}
  }

  var systemCallBundle: Koinos_Protocol_contract_call_bundle {
    get {
      if case .systemCallBundle(let v)? = target {return v}
      return Koinos_Protocol_contract_call_bundle()
    }
    set {target = .systemCallBundle(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    case thunkID(UInt32)
    case systemCallBundle(Koinos_Protocol_contract_call_bundle)

  #if !swift(>=4.1)
    static func ==(lhs: Koinos_Protocol_system_call_target.OneOf_Target, rhs: Koinos_Protocol_system_call_target.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.thunkID, .thunkID): return {
        guard case .thunkID(let l) = lhs, case .thunkID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemCallBundle, .systemCallBundle): return {
        guard case .systemCallBundle(let l) = lhs, case .systemCallBundle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Koinos_Protocol_upload_contract_operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contractID: Data = Data()

  var bytecode: Data = Data()

  var abi: String = String()

  var authorizesCallContract: Bool = false

  var authorizesTransactionApplication: Bool = false

  var authorizesUploadContract: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_call_contract_operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contractID: Data = Data()

  var entryPoint: UInt32 = 0

  var args: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_set_system_call_operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callID: UInt32 = 0

  var target: Koinos_Protocol_system_call_target {
    get {return _target ?? Koinos_Protocol_system_call_target()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: Koinos_Protocol_system_call_target? = nil
}

struct Koinos_Protocol_set_system_contract_operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contractID: Data = Data()

  var systemContract: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var op: Koinos_Protocol_operation.OneOf_Op? = nil

  var uploadContract: Koinos_Protocol_upload_contract_operation {
    get {
      if case .uploadContract(let v)? = op {return v}
      return Koinos_Protocol_upload_contract_operation()
    }
    set {op = .uploadContract(newValue)}
  }

  var callContract: Koinos_Protocol_call_contract_operation {
    get {
      if case .callContract(let v)? = op {return v}
      return Koinos_Protocol_call_contract_operation()
    }
    set {op = .callContract(newValue)}
  }

  var setSystemCall: Koinos_Protocol_set_system_call_operation {
    get {
      if case .setSystemCall(let v)? = op {return v}
      return Koinos_Protocol_set_system_call_operation()
    }
    set {op = .setSystemCall(newValue)}
  }

  var setSystemContract: Koinos_Protocol_set_system_contract_operation {
    get {
      if case .setSystemContract(let v)? = op {return v}
      return Koinos_Protocol_set_system_contract_operation()
    }
    set {op = .setSystemContract(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Op: Equatable {
    case uploadContract(Koinos_Protocol_upload_contract_operation)
    case callContract(Koinos_Protocol_call_contract_operation)
    case setSystemCall(Koinos_Protocol_set_system_call_operation)
    case setSystemContract(Koinos_Protocol_set_system_contract_operation)

  #if !swift(>=4.1)
    static func ==(lhs: Koinos_Protocol_operation.OneOf_Op, rhs: Koinos_Protocol_operation.OneOf_Op) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uploadContract, .uploadContract): return {
        guard case .uploadContract(let l) = lhs, case .uploadContract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callContract, .callContract): return {
        guard case .callContract(let l) = lhs, case .callContract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSystemCall, .setSystemCall): return {
        guard case .setSystemCall(let l) = lhs, case .setSystemCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSystemContract, .setSystemContract): return {
        guard case .setSystemContract(let l) = lhs, case .setSystemContract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Koinos_Protocol_transaction_header {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: Data = Data()

  var rcLimit: UInt64 = 0

  var nonce: Data = Data()

  var operationMerkleRoot: Data = Data()

  var payer: Data = Data()

  var payee: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var header: Koinos_Protocol_transaction_header {
    get {return _header ?? Koinos_Protocol_transaction_header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var operations: [Koinos_Protocol_operation] = []

  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Koinos_Protocol_transaction_header? = nil
}

struct Koinos_Protocol_transaction_receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var payer: Data = Data()

  var maxPayerRc: UInt64 = 0

  var rcLimit: UInt64 = 0

  var rcUsed: UInt64 = 0

  var diskStorageUsed: UInt64 = 0

  var networkBandwidthUsed: UInt64 = 0

  var computeBandwidthUsed: UInt64 = 0

  var reverted: Bool = false

  var events: [Koinos_Protocol_event_data] = []

  var logs: [String] = []

  var stateDeltaEntries: [Koinos_Protocol_state_delta_entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_block_header {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previous: Data = Data()

  var height: UInt64 = 0

  var timestamp: UInt64 = 0

  var previousStateMerkleRoot: Data = Data()

  var transactionMerkleRoot: Data = Data()

  var signer: Data = Data()

  var approvedProposals: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var header: Koinos_Protocol_block_header {
    get {return _header ?? Koinos_Protocol_block_header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var transactions: [Koinos_Protocol_transaction] = []

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Koinos_Protocol_block_header? = nil
}

struct Koinos_Protocol_block_receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var height: UInt64 = 0

  var diskStorageUsed: UInt64 = 0

  var networkBandwidthUsed: UInt64 = 0

  var computeBandwidthUsed: UInt64 = 0

  var stateMerkleRoot: Data = Data()

  var events: [Koinos_Protocol_event_data] = []

  var transactionReceipts: [Koinos_Protocol_transaction_receipt] = []

  var logs: [String] = []

  var diskStorageCharged: UInt64 = 0

  var networkBandwidthCharged: UInt64 = 0

  var computeBandwidthCharged: UInt64 = 0

  var stateDeltaEntries: [Koinos_Protocol_state_delta_entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Koinos_Protocol_state_delta_entry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectSpace: Koinos_Protocol_object_space {
    get {return _objectSpace ?? Koinos_Protocol_object_space()}
    set {_objectSpace = newValue}
  }
  /// Returns true if `objectSpace` has been explicitly set.
  var hasObjectSpace: Bool {return self._objectSpace != nil}
  /// Clears the value of `objectSpace`. Subsequent reads from it will return its default value.
  mutating func clearObjectSpace() {self._objectSpace = nil}

  var key: Data = Data()

  var value: Data {
    get {return _value ?? Data()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _objectSpace: Koinos_Protocol_object_space? = nil
  fileprivate var _value: Data? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Koinos_Protocol_object_space: @unchecked Sendable {}
extension Koinos_Protocol_event_data: @unchecked Sendable {}
extension Koinos_Protocol_contract_call_bundle: @unchecked Sendable {}
extension Koinos_Protocol_system_call_target: @unchecked Sendable {}
extension Koinos_Protocol_system_call_target.OneOf_Target: @unchecked Sendable {}
extension Koinos_Protocol_upload_contract_operation: @unchecked Sendable {}
extension Koinos_Protocol_call_contract_operation: @unchecked Sendable {}
extension Koinos_Protocol_set_system_call_operation: @unchecked Sendable {}
extension Koinos_Protocol_set_system_contract_operation: @unchecked Sendable {}
extension Koinos_Protocol_operation: @unchecked Sendable {}
extension Koinos_Protocol_operation.OneOf_Op: @unchecked Sendable {}
extension Koinos_Protocol_transaction_header: @unchecked Sendable {}
extension Koinos_Protocol_transaction: @unchecked Sendable {}
extension Koinos_Protocol_transaction_receipt: @unchecked Sendable {}
extension Koinos_Protocol_block_header: @unchecked Sendable {}
extension Koinos_Protocol_block: @unchecked Sendable {}
extension Koinos_Protocol_block_receipt: @unchecked Sendable {}
extension Koinos_Protocol_state_delta_entry: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "koinos.protocol"

extension Koinos_Protocol_object_space: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".object_space"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "system"),
    2: .same(proto: "zone"),
    3: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.system) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.system != false {
      try visitor.visitSingularBoolField(value: self.system, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularBytesField(value: self.zone, fieldNumber: 2)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_object_space, rhs: Koinos_Protocol_object_space) -> Bool {
    if lhs.system != rhs.system {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_event_data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".event_data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .same(proto: "source"),
    3: .same(proto: "name"),
    4: .same(proto: "data"),
    5: .same(proto: "impacted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.impacted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularBytesField(value: self.source, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.impacted.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.impacted, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_event_data, rhs: Koinos_Protocol_event_data) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.source != rhs.source {return false}
    if lhs.name != rhs.name {return false}
    if lhs.data != rhs.data {return false}
    if lhs.impacted != rhs.impacted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_contract_call_bundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".contract_call_bundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_id"),
    2: .standard(proto: "entry_point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.entryPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractID, fieldNumber: 1)
    }
    if self.entryPoint != 0 {
      try visitor.visitSingularUInt32Field(value: self.entryPoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_contract_call_bundle, rhs: Koinos_Protocol_contract_call_bundle) -> Bool {
    if lhs.contractID != rhs.contractID {return false}
    if lhs.entryPoint != rhs.entryPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_system_call_target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".system_call_target"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "thunk_id"),
    2: .standard(proto: "system_call_bundle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .thunkID(v)
        }
      }()
      case 2: try {
        var v: Koinos_Protocol_contract_call_bundle?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .systemCallBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .systemCallBundle(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .thunkID?: try {
      guard case .thunkID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .systemCallBundle?: try {
      guard case .systemCallBundle(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_system_call_target, rhs: Koinos_Protocol_system_call_target) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_upload_contract_operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".upload_contract_operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_id"),
    2: .same(proto: "bytecode"),
    3: .same(proto: "abi"),
    4: .standard(proto: "authorizes_call_contract"),
    5: .standard(proto: "authorizes_transaction_application"),
    6: .standard(proto: "authorizes_upload_contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.bytecode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.abi) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.authorizesCallContract) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.authorizesTransactionApplication) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.authorizesUploadContract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractID, fieldNumber: 1)
    }
    if !self.bytecode.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytecode, fieldNumber: 2)
    }
    if !self.abi.isEmpty {
      try visitor.visitSingularStringField(value: self.abi, fieldNumber: 3)
    }
    if self.authorizesCallContract != false {
      try visitor.visitSingularBoolField(value: self.authorizesCallContract, fieldNumber: 4)
    }
    if self.authorizesTransactionApplication != false {
      try visitor.visitSingularBoolField(value: self.authorizesTransactionApplication, fieldNumber: 5)
    }
    if self.authorizesUploadContract != false {
      try visitor.visitSingularBoolField(value: self.authorizesUploadContract, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_upload_contract_operation, rhs: Koinos_Protocol_upload_contract_operation) -> Bool {
    if lhs.contractID != rhs.contractID {return false}
    if lhs.bytecode != rhs.bytecode {return false}
    if lhs.abi != rhs.abi {return false}
    if lhs.authorizesCallContract != rhs.authorizesCallContract {return false}
    if lhs.authorizesTransactionApplication != rhs.authorizesTransactionApplication {return false}
    if lhs.authorizesUploadContract != rhs.authorizesUploadContract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_call_contract_operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".call_contract_operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_id"),
    2: .standard(proto: "entry_point"),
    3: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.entryPoint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractID, fieldNumber: 1)
    }
    if self.entryPoint != 0 {
      try visitor.visitSingularUInt32Field(value: self.entryPoint, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitSingularBytesField(value: self.args, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_call_contract_operation, rhs: Koinos_Protocol_call_contract_operation) -> Bool {
    if lhs.contractID != rhs.contractID {return false}
    if lhs.entryPoint != rhs.entryPoint {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_set_system_call_operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".set_system_call_operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.callID != 0 {
      try visitor.visitSingularUInt32Field(value: self.callID, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_set_system_call_operation, rhs: Koinos_Protocol_set_system_call_operation) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs._target != rhs._target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_set_system_contract_operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".set_system_contract_operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_id"),
    2: .standard(proto: "system_contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.systemContract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractID, fieldNumber: 1)
    }
    if self.systemContract != false {
      try visitor.visitSingularBoolField(value: self.systemContract, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_set_system_contract_operation, rhs: Koinos_Protocol_set_system_contract_operation) -> Bool {
    if lhs.contractID != rhs.contractID {return false}
    if lhs.systemContract != rhs.systemContract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upload_contract"),
    2: .standard(proto: "call_contract"),
    3: .standard(proto: "set_system_call"),
    4: .standard(proto: "set_system_contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Koinos_Protocol_upload_contract_operation?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .uploadContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .uploadContract(v)
        }
      }()
      case 2: try {
        var v: Koinos_Protocol_call_contract_operation?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .callContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .callContract(v)
        }
      }()
      case 3: try {
        var v: Koinos_Protocol_set_system_call_operation?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .setSystemCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .setSystemCall(v)
        }
      }()
      case 4: try {
        var v: Koinos_Protocol_set_system_contract_operation?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .setSystemContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .setSystemContract(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.op {
    case .uploadContract?: try {
      guard case .uploadContract(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .callContract?: try {
      guard case .callContract(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setSystemCall?: try {
      guard case .setSystemCall(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .setSystemContract?: try {
      guard case .setSystemContract(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_operation, rhs: Koinos_Protocol_operation) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_transaction_header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".transaction_header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "rc_limit"),
    3: .same(proto: "nonce"),
    4: .standard(proto: "operation_merkle_root"),
    5: .same(proto: "payer"),
    6: .same(proto: "payee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.rcLimit) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.operationMerkleRoot) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.payer) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.payee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainID.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainID, fieldNumber: 1)
    }
    if self.rcLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.rcLimit, fieldNumber: 2)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 3)
    }
    if !self.operationMerkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.operationMerkleRoot, fieldNumber: 4)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularBytesField(value: self.payer, fieldNumber: 5)
    }
    if !self.payee.isEmpty {
      try visitor.visitSingularBytesField(value: self.payee, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_transaction_header, rhs: Koinos_Protocol_transaction_header) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.rcLimit != rhs.rcLimit {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.operationMerkleRoot != rhs.operationMerkleRoot {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.payee != rhs.payee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "header"),
    3: .same(proto: "operations"),
    4: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_transaction, rhs: Koinos_Protocol_transaction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._header != rhs._header {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_transaction_receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".transaction_receipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "payer"),
    3: .standard(proto: "max_payer_rc"),
    4: .standard(proto: "rc_limit"),
    5: .standard(proto: "rc_used"),
    6: .standard(proto: "disk_storage_used"),
    7: .standard(proto: "network_bandwidth_used"),
    8: .standard(proto: "compute_bandwidth_used"),
    9: .same(proto: "reverted"),
    10: .same(proto: "events"),
    11: .same(proto: "logs"),
    12: .standard(proto: "state_delta_entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payer) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxPayerRc) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.rcLimit) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.rcUsed) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.diskStorageUsed) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.networkBandwidthUsed) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.computeBandwidthUsed) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reverted) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.logs) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.stateDeltaEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularBytesField(value: self.payer, fieldNumber: 2)
    }
    if self.maxPayerRc != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPayerRc, fieldNumber: 3)
    }
    if self.rcLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.rcLimit, fieldNumber: 4)
    }
    if self.rcUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.rcUsed, fieldNumber: 5)
    }
    if self.diskStorageUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.diskStorageUsed, fieldNumber: 6)
    }
    if self.networkBandwidthUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.networkBandwidthUsed, fieldNumber: 7)
    }
    if self.computeBandwidthUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeBandwidthUsed, fieldNumber: 8)
    }
    if self.reverted != false {
      try visitor.visitSingularBoolField(value: self.reverted, fieldNumber: 9)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 10)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logs, fieldNumber: 11)
    }
    if !self.stateDeltaEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stateDeltaEntries, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_transaction_receipt, rhs: Koinos_Protocol_transaction_receipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.maxPayerRc != rhs.maxPayerRc {return false}
    if lhs.rcLimit != rhs.rcLimit {return false}
    if lhs.rcUsed != rhs.rcUsed {return false}
    if lhs.diskStorageUsed != rhs.diskStorageUsed {return false}
    if lhs.networkBandwidthUsed != rhs.networkBandwidthUsed {return false}
    if lhs.computeBandwidthUsed != rhs.computeBandwidthUsed {return false}
    if lhs.reverted != rhs.reverted {return false}
    if lhs.events != rhs.events {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.stateDeltaEntries != rhs.stateDeltaEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_block_header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".block_header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previous"),
    2: .same(proto: "height"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "previous_state_merkle_root"),
    5: .standard(proto: "transaction_merkle_root"),
    6: .same(proto: "signer"),
    7: .standard(proto: "approved_proposals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.previous) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.previousStateMerkleRoot) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.transactionMerkleRoot) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.approvedProposals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previous.isEmpty {
      try visitor.visitSingularBytesField(value: self.previous, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if !self.previousStateMerkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousStateMerkleRoot, fieldNumber: 4)
    }
    if !self.transactionMerkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionMerkleRoot, fieldNumber: 5)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 6)
    }
    if !self.approvedProposals.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvedProposals, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_block_header, rhs: Koinos_Protocol_block_header) -> Bool {
    if lhs.previous != rhs.previous {return false}
    if lhs.height != rhs.height {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.previousStateMerkleRoot != rhs.previousStateMerkleRoot {return false}
    if lhs.transactionMerkleRoot != rhs.transactionMerkleRoot {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.approvedProposals != rhs.approvedProposals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "header"),
    3: .same(proto: "transactions"),
    4: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_block, rhs: Koinos_Protocol_block) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._header != rhs._header {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_block_receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".block_receipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "height"),
    3: .standard(proto: "disk_storage_used"),
    4: .standard(proto: "network_bandwidth_used"),
    5: .standard(proto: "compute_bandwidth_used"),
    6: .standard(proto: "state_merkle_root"),
    7: .same(proto: "events"),
    8: .standard(proto: "transaction_receipts"),
    9: .same(proto: "logs"),
    10: .standard(proto: "disk_storage_charged"),
    11: .standard(proto: "network_bandwidth_charged"),
    12: .standard(proto: "compute_bandwidth_charged"),
    13: .standard(proto: "state_delta_entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.diskStorageUsed) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.networkBandwidthUsed) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.computeBandwidthUsed) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.stateMerkleRoot) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.transactionReceipts) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.logs) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.diskStorageCharged) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.networkBandwidthCharged) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.computeBandwidthCharged) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.stateDeltaEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.diskStorageUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.diskStorageUsed, fieldNumber: 3)
    }
    if self.networkBandwidthUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.networkBandwidthUsed, fieldNumber: 4)
    }
    if self.computeBandwidthUsed != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeBandwidthUsed, fieldNumber: 5)
    }
    if !self.stateMerkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.stateMerkleRoot, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.transactionReceipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionReceipts, fieldNumber: 8)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logs, fieldNumber: 9)
    }
    if self.diskStorageCharged != 0 {
      try visitor.visitSingularUInt64Field(value: self.diskStorageCharged, fieldNumber: 10)
    }
    if self.networkBandwidthCharged != 0 {
      try visitor.visitSingularUInt64Field(value: self.networkBandwidthCharged, fieldNumber: 11)
    }
    if self.computeBandwidthCharged != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeBandwidthCharged, fieldNumber: 12)
    }
    if !self.stateDeltaEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stateDeltaEntries, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_block_receipt, rhs: Koinos_Protocol_block_receipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.height != rhs.height {return false}
    if lhs.diskStorageUsed != rhs.diskStorageUsed {return false}
    if lhs.networkBandwidthUsed != rhs.networkBandwidthUsed {return false}
    if lhs.computeBandwidthUsed != rhs.computeBandwidthUsed {return false}
    if lhs.stateMerkleRoot != rhs.stateMerkleRoot {return false}
    if lhs.events != rhs.events {return false}
    if lhs.transactionReceipts != rhs.transactionReceipts {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.diskStorageCharged != rhs.diskStorageCharged {return false}
    if lhs.networkBandwidthCharged != rhs.networkBandwidthCharged {return false}
    if lhs.computeBandwidthCharged != rhs.computeBandwidthCharged {return false}
    if lhs.stateDeltaEntries != rhs.stateDeltaEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Koinos_Protocol_state_delta_entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".state_delta_entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_space"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._objectSpace) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._objectSpace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Koinos_Protocol_state_delta_entry, rhs: Koinos_Protocol_state_delta_entry) -> Bool {
    if lhs._objectSpace != rhs._objectSpace {return false}
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
