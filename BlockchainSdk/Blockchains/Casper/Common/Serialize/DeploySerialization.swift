import Foundation
import CryptoKit

/**
 Class for Deploy serialization
 */
enum DeploySerialization {
    /**
     Serialization for a Deploy object
     - Parameter : a deploy object
     - Returns: String represent the serialization of the deploy, with the rule of making serialization like this:
     Serialization string = deployHeader.Serialization + hash + payment.Serialization + session.Serialization + approvals.Serialization
     */

    static func serialize(fromDeploy: CSPRDeploy) -> String {
        var retStr = ""
        retStr = DeployHeaderSerialization.serialize(from: fromDeploy.header)
        retStr = retStr + fromDeploy.hash
        retStr = retStr + ExecutableDeployItemSerializaton.serialize(from: fromDeploy.payment!)
        retStr = retStr + ExecutableDeployItemSerializaton.serialize(from: fromDeploy.session!)
        retStr = retStr + DeployApprovalSerialization.serialize(from: fromDeploy.approvals)
        return retStr
    }

    /**
     Get body hash of a deploy
     - Parameter : a deploy object
     - Returns: String represent the body hash of the deploy. The hash is generated by using blake2b256b hash over the concatenation of payment serialization + session serialization
     */

    static func getBodyHash(fromDeploy: CSPRDeploy) -> String {
        var bodySerializedStr: String = ExecutableDeployItemSerializaton.serialize(from: fromDeploy.payment!)
        bodySerializedStr = bodySerializedStr + ExecutableDeployItemSerializaton.serialize(from: fromDeploy.session!)
        let blake2Data = Data(hexString: bodySerializedStr)
        let hash = blake2Data.hashBlake2b(outputLength: 32)
        return hash?.toHexString() ?? ""
    }

    /**
     Get header hash of a deploy
     - Parameter : a deploy header
     - Returns: String represent the body hash of the deploy header. The hash is generated by using blake2b256b hash over the header serialization.
     */

    static func getHeaderHash(fromDeployHeader: CSPRDeployHeader) -> String {
        let headerSerialized: String = DeployHeaderSerialization.serialize(from: fromDeployHeader)
        let blake2Data = Data(hexString: headerSerialized)
        let hash = blake2Data.hashBlake2b(outputLength: 32)
        return hash?.toHexString() ?? ""
    }
}

/**
 Class for Deploy Header  serialization
 */
enum DeployHeaderSerialization {
    /**
     Serialization for DeployHeader
     - Parameter : a deploy header object
     - Returns: String represents the serialization of the deploy header
     */

    static func serialize(from: CSPRDeployHeader) -> String {
        var retStr = from.account + CLTypeSerializeHelper.uInt64Serialize(input: CSPRUtils.dateStrToMilisecond(dateStr: from.timestamp)) + CLTypeSerializeHelper.uInt64Serialize(input: CSPRUtils.ttlToMilisecond(ttl: from.ttl)) + CLTypeSerializeHelper.uInt64Serialize(input: from.gasPrice) + from.bodyHash
        var depStr = CLTypeSerializeHelper.uInt32Serialize(input: UInt32(from.dependencies.count))
        if !from.dependencies.isEmpty {
            for element in from.dependencies {
                depStr = depStr + element
            }
        }
        retStr = retStr + depStr
        let chainSerialization = CLTypeSerializeHelper.stringSerialize(input: from.chainName)
        retStr = retStr + chainSerialization
        return retStr
    }
}

/**
 Class for ExecutableDeployItem  serialization
 */
enum ExecutableDeployItemSerializaton {
    /**
     Serialization for NamedArg list
     - Parameter : NamedArg list
     - Returns: String represents the serialization of the NamedArg list
     Serialize rule: if the args list is empty then just return the U32Serialize(0), which is 00000000
        else if the args list is not empty then return value = UInt32.serialize(args.count) + each args.serialize
        Rule for each args serialize:
        args serialize return value = StringSerialize(args.name) + UInt32.seriallize(bytes.length) + bytes + CLType.tag
     */

    static func nameArgListSerialize(from: [NamedArg]) -> String {
        if from.isEmpty {
            return "00000000"
        }
        let size = UInt32(from.count)
        // concatenate each arg item in the args list
        var argStr: String = CLTypeSerializeHelper.uInt32Serialize(input: size)
        for nameArg in from {
            argStr = argStr + CLTypeSerializeHelper.stringSerialize(input: nameArg.name)
            do {
                let clValueSerialize = try CLTypeSerializeHelper.CLValueSerialize(input: nameArg.argsItem.parsed)
                let clValueSerializeSize = UInt32(clValueSerialize.count / 2)
                argStr = argStr + CLTypeSerializeHelper.uInt32Serialize(input: clValueSerializeSize) + clValueSerialize // nameArg.argsItem.bytes
                argStr = argStr + CLTypeSerializeHelper.CLTypeSerialize(input: nameArg.argsItem.clType)
            } catch {
                NSLog("Error serialize NameArgs \(error)")
            }
        }
        return argStr
    }

    /**
     Serialization for ExecutableDeployItem
     - Parameter : ExecutableDeployItem object
     - Returns: String represents the serialization of the ExecutableDeployItem, taking account to the ExecutableDeployItem value type (of enumeration type), which can be of the following types:
        - ModuleBytes
        - StoredContractByHash
        - StoredContractByName
        - StoredVersionedContractByHash
        - StoredVersionedContractByName
        - Transfer
     */
    static func serialize(from: ExecutableDeployItem) -> String {
        switch from {
        // /- Rule for serialization: for .ModuleBytes:
        // /result = "00" + module_bytes.serialize + args.serialize
        // / - first value: module_bytes.serialize
        // / if the module_bytes is blank or "" then module_bytes.serialize = "00000000" (which equals UInt32.serialize(0))
        // / if the module_bytes is not blank, then module_bytes.serialize = CLValue.String.Serialize(module_bytes) - serialize module_bytes as type CLType.String
        // / - second value: args.serialize
        // / using NameArgListSerialize for the args list
        case .moduleBytes(let moduleBytes, let args):
            var ret: String = "00"
            if moduleBytes.value == "" {
                ret = "00" + CLTypeSerializeHelper.uInt32Serialize(input: 0)
            } else {
                // let module_bytesLength = UInt32(module_bytes.value.count)
                ret = "00" + CLTypeSerializeHelper.stringSerialize(input: moduleBytes.value)
            }
            let argStr = ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
            ret = ret + argStr
            return ret
        case .storedContractByHash(let hash, let entryPoint, let args):
            var ret: String = "01"
            ret = ret + hash
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: entryPoint)
            ret = ret + ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
            return ret
        case .storedContractByName(let name, let entryPoint, let args):
            var ret: String = "02"
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: name)
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: entryPoint)
            ret = ret + ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
            return ret
        case .storedVersionedContractByHash(let hash, let version, let entryPoint, let args):
            var ret: String = "03"
            ret = ret + hash
            if let realVersion = version {
                if realVersion == versionNullValue {
                    ret = ret + "00"
                } else { // version with value # NONE
                    ret = ret + "01" + CLTypeSerializeHelper.uInt32Serialize(input: realVersion)
                }
            } else { // version with value NONE
                ret = ret + "00"
            }
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: entryPoint)
            ret = ret + ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
            return ret
        case .storedVersionedContractByName(let name, let version, let entryPoint, let args):
            var ret: String = "04"
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: name)
            if let realVersion = version {
                if realVersion == versionNullValue {
                    ret = ret + "00"
                } else { // version with value # NONE
                    ret = ret + "01" + CLTypeSerializeHelper.uInt32Serialize(input: realVersion)
                }
            } else {
                ret = ret + "00"
            }
            ret = ret + CLTypeSerializeHelper.stringSerialize(input: entryPoint)
            ret = ret + ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
            return ret
        case .transfer(let args):
            return "05" + ExecutableDeployItemSerializaton.nameArgListSerialize(from: args.listNamedArg)
        case .none:
            return ""
        }
    }
}

/**
 Class for Approval serialization
 */

enum DeployApprovalSerialization {
    /**
     Serialization for DeployApprovalItem list
     - Parameter : DeployApprovalItem list
     - Returns: String represents the serialization of the DeployApprovalItem list
     - Rule for serialization: return value = UInt32.serialize(totalApproval) + signer + singnature
     - If total approval = 0 then return UIn32.serialize(0) which mean "00000000"
     */

    static func serialize(from: [CSPRDeployApprovalItem]) -> String {
        let totalApproval = from.count
        if totalApproval == 0 {
            return "00000000"
        }
        var retStr = CLTypeSerializeHelper.uInt32Serialize(input: UInt32(totalApproval))
        for element in from {
            retStr = retStr + element.signer + element.signature
        }
        return retStr
    }
}
